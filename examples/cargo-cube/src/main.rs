#![no_std]
#![no_main]
extern crate alloc;
use kos::println;

extern "C" {
    // GLdc C library Bindings
    fn glBegin(mode: u32);
    fn glBindTexture(target: u32, texture: u32);
    fn glEnable(cap: u32);
    fn glEnd();
    fn glClear(mask: u32);
    fn glClearColor(red: f32, green: f32, blue: f32, alpha: f32);
    fn glClearDepth(depth: f32);
    fn glColor3f(red: f32, green: f32, blue: f32);
    fn glCompressedTexImage2DARB(target: u32, level: i32, internalformat: u32,
                                 width: u32, height: u32, border: i32,
                                 image_size: u32, data: *const u8);
    fn glDeleteTextures(n: u32, textures: *mut u32);
    fn glDepthFunc(func: u32);
    fn glGenTextures(n: u32, textures: *mut u32);
    fn glKosInit();
    fn glKosSwapBuffers();
    fn glLoadIdentity();
    fn glMatrixMode(mode: u32);
    fn glRotatef(angle: f32, x: f32, y: f32, z: f32);
    fn glShadeModel(mode: u32);
    fn glTexCoord2f(s: f32, t: f32);
    fn glTranslatef(x: f32, y: f32, z: f32);
    fn glVertex3f(x: f32, y: f32, z: f32);
    fn gluPerspective(fovy: f32, aspect: f32, zNear: f32, zFar: f32);

    // KallistiOS C library bindings
    fn maple_enum_type(n: i32, func: u32) -> *mut maple_device;
    fn maple_dev_status(dev: *mut maple_device) -> *mut cont_state;
}

// KallistiOS controller constant
const MAPLE_FUNC_CONTROLLER: u32             = 0x01000000;

// maple_device represents a Dreamcast controller peripheral
#[repr(C)]
struct maple_device {
    valid: i32,
    port: i32,
    unit: i32,
    functions: u32,
    function_data: [u32; 3],
    area_code: u8,
    connector_direction: u8,
    product_name: [u8; 30],
    product_license: [u8; 60],
    standby_power: u16,
    max_power: u16,
}

// cont_state represents the state of the controller buttons
#[repr(C)]
struct cont_state {
    buttons: u32,
    ltrig: i32,
    rtrig: i32,
    joyx: i32,
    joyy: i32,
    joy2x: i32,
    joy2y: i32,
}

// Define the OpenGL constants we'll be using
const GL_TEXTURE_2D: u32                     = 0x0001;
const GL_COMPRESSED_RGB_565_VQ_TWID_KOS: u32 = 0xeee8;
const GL_COLOR_BUFFER_BIT: u32               = 0x4000;
const GL_DEPTH_BUFFER_BIT: u32               = 0x0100;
const GL_QUADS: u32                          = 0x0007;
const GL_PROJECTION: u32                     = 0x1701;
const GL_MODELVIEW: u32                      = 0x1700;
const GL_SMOOTH: u32                         = 0x1d01;
const GL_DEPTH_TEST: u32                     = 0x0b71;
const GL_LEQUAL: u32                         = 0x0203;

        // Include texture data generated by build script
static CLAW_DATA: &[u8] = include_bytes!("../rsrc/tex_claw.vq");
static DC_DATA: &[u8] = include_bytes!("../rsrc/tex_dc.vq");
static DCWIKI_DATA: &[u8] = include_bytes!("../rsrc/tex_dcwiki.vq");
static GCC_DATA: &[u8] = include_bytes!("../rsrc/tex_gcc.vq");
static KOS_DATA: &[u8] = include_bytes!("../rsrc/tex_kos.vq");
static RUST_DATA: &[u8] = include_bytes!("../rsrc/tex_rust.vq");

#[no_mangle]
pub fn main(_argc: isize, _argv: *const *const u8) -> isize {
    unsafe {
        // Initialize GLdc
        glKosInit();

        // Say hello to the world!
        println!("\nWelcome to Rust on Sega Dreamcast!");

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(45.0, 640.0 / 480.0, 0.1, 100.0);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();

        glEnable(GL_TEXTURE_2D);
        glShadeModel(GL_SMOOTH);
        glClearColor(0.0, 0.0, 0.0, 0.5);
        glClearDepth(1.0);
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LEQUAL);

        let mut tex_claw: u32 = 0;
        glGenTextures(1, &mut tex_claw);
        glBindTexture(GL_TEXTURE_2D, tex_claw);
        glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB_565_VQ_TWID_KOS,
                                  512, 512, 0, CLAW_DATA.len() as u32, CLAW_DATA.as_ptr());

        let mut tex_dc: u32 = 0;
        glGenTextures(1, &mut tex_dc);
        glBindTexture(GL_TEXTURE_2D, tex_dc);
        glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB_565_VQ_TWID_KOS,
                                  512, 512, 0, DC_DATA.len() as u32, DC_DATA.as_ptr());

        let mut tex_dcwiki: u32 = 0;
        glGenTextures(1, &mut tex_dcwiki);
        glBindTexture(GL_TEXTURE_2D, tex_dcwiki);
        glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB_565_VQ_TWID_KOS,
                                  512, 512, 0, DCWIKI_DATA.len() as u32, DCWIKI_DATA.as_ptr());

        let mut tex_gcc: u32 = 0;
        glGenTextures(1, &mut tex_gcc);
        glBindTexture(GL_TEXTURE_2D, tex_gcc);
        glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB_565_VQ_TWID_KOS,
                                  512, 512, 0, GCC_DATA.len() as u32, GCC_DATA.as_ptr());

        let mut tex_kos: u32 = 0;
        glGenTextures(1, &mut tex_kos);
        glBindTexture(GL_TEXTURE_2D, tex_kos);
        glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB_565_VQ_TWID_KOS,
                                  512, 512, 0, KOS_DATA.len() as u32, KOS_DATA.as_ptr());

        let mut tex_rust: u32 = 0;
        glGenTextures(1, &mut tex_rust);
        glBindTexture(GL_TEXTURE_2D, tex_rust);
        glCompressedTexImage2DARB(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGB_565_VQ_TWID_KOS,
                                  512, 512, 0, RUST_DATA.len() as u32, RUST_DATA.as_ptr());

        let mut xrot: f32 = 0.0;
        let mut yrot: f32 = 0.0;
        let mut zrot: f32 = 0.0;

        let mut draw_gl = || {
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            glLoadIdentity();
            glTranslatef(0.0, 0.0, -5.0);

            glRotatef(xrot, 1.0, 0.0, 0.0);
            glRotatef(yrot, 0.0, 1.0, 0.0);
            glRotatef(zrot, 0.0, 0.0, 1.0);

            // Front face
            glBindTexture(GL_TEXTURE_2D, tex_claw);
            glBegin(GL_QUADS);

            glColor3f(1.0, 1.0, 1.0);
            glTexCoord2f(1.0, 0.0);
            glVertex3f(-1.0, -1.0,  1.0);
            glTexCoord2f(0.0, 0.0);
            glVertex3f(1.0, -1.0,  1.0);
            glTexCoord2f(0.0, 1.0);
            glVertex3f(1.0,  1.0,  1.0);
            glTexCoord2f(1.0, 1.0);
            glVertex3f(-1.0,  1.0,  1.0);

            glEnd();

            // Back face
            glBindTexture(GL_TEXTURE_2D, tex_gcc);
            glBegin(GL_QUADS);

            glColor3f(1.0, 1.0, 1.0);
            glTexCoord2f(0.0, 0.0);
            glVertex3f(-1.0, -1.0, -1.0);
            glTexCoord2f(0.0, 1.0);
            glVertex3f(-1.0,  1.0, -1.0);
            glTexCoord2f(1.0, 1.0);
            glVertex3f(1.0,  1.0, -1.0);
            glTexCoord2f(1.0, 0.0);
            glVertex3f(1.0, -1.0, -1.0);

            glEnd();

            // Top face
            glBindTexture(GL_TEXTURE_2D, tex_dcwiki);
            glBegin(GL_QUADS);

            glColor3f(1.0, 1.0, 1.0);
            glTexCoord2f(1.0, 1.0);
            glVertex3f(-1.0,  1.0, -1.0);
            glTexCoord2f(1.0, 0.0);
            glVertex3f(-1.0,  1.0,  1.0);
            glTexCoord2f(0.0, 0.0);
            glVertex3f(1.0,  1.0,  1.0);
            glTexCoord2f(0.0, 1.0);
            glVertex3f(1.0,  1.0, -1.0);

            glEnd();

            // Bottom face
            glBindTexture(GL_TEXTURE_2D, tex_kos);
            glBegin(GL_QUADS);

            glColor3f(1.0, 1.0, 1.0);
            glTexCoord2f(0.0, 1.0);
            glVertex3f(-1.0, -1.0, -1.0);
            glTexCoord2f(1.0, 1.0);
            glVertex3f(1.0, -1.0, -1.0);
            glTexCoord2f(1.0, 0.0);
            glVertex3f(1.0, -1.0,  1.0);
            glTexCoord2f(0.0, 0.0);
            glVertex3f(-1.0, -1.0,  1.0);

            glEnd();

            // Right face
            glBindTexture(GL_TEXTURE_2D, tex_dc);
            glBegin(GL_QUADS);

            glColor3f(0.0, 1.0, 0.0);
            glTexCoord2f(0.0, 0.0);
            glVertex3f(1.0, -1.0, -1.0);
            glColor3f(0.3, 0.5, 1.0);
            glTexCoord2f(0.0, 1.0);
            glVertex3f(1.0,  1.0, -1.0);
            glColor3f(1.0, 0.3, 0.5);
            glTexCoord2f(1.0, 1.0);
            glVertex3f(1.0,  1.0,  1.0);
            glColor3f(0.5, 0.5, 0.5);
            glTexCoord2f(1.0, 0.0);
            glVertex3f(1.0, -1.0,  1.0);

            glEnd();

            // Left face
            glBindTexture(GL_TEXTURE_2D, tex_rust);
            glBegin(GL_QUADS);

            glColor3f(1.0, 0.0, 0.0);
            glTexCoord2f(1.0, 0.0);
            glVertex3f(-1.0, -1.0, -1.0);
            glColor3f(1.0, 1.0, 0.0);
            glTexCoord2f(0.0, 0.0);
            glVertex3f(-1.0, -1.0,  1.0);
            glColor3f(0.0, 1.0, 1.0);
            glTexCoord2f(0.0, 1.0);
            glVertex3f(-1.0,  1.0,  1.0);
            glColor3f(0.0, 0.0, 1.0);
            glTexCoord2f(1.0, 1.0);
            glVertex3f(-1.0,  1.0, -1.0);

            glEnd();

            xrot += 1.4;
            yrot += 1.1;
            zrot += 1.8;
        };

        // Done setting up, now let's loop!
        loop {
            // Exit if there are no controllers
            let mapledev = maple_enum_type(0, MAPLE_FUNC_CONTROLLER);

            if (mapledev as *mut u8) == core::ptr::null_mut() {
                println!("No controllers connected! Quitting...");
                break;
            }

            // Exit if input cannot be read
            let state: *mut cont_state = maple_dev_status(mapledev);

            if (state as *mut u8) == core::ptr::null_mut() {
                println!("Error reading controller! Quitting...");
                break;
            }

            // Exit when the user presses start
            if ((*state).buttons >> 3) == 1 {
                println!("Start pressed. Goodbye!");
                break;
            }

            draw_gl();

            glKosSwapBuffers();
        }

        // Clean up our textures
        glDeleteTextures(1, &mut tex_claw);
        glDeleteTextures(1, &mut tex_dc);
        glDeleteTextures(1, &mut tex_dcwiki);
        glDeleteTextures(1, &mut tex_gcc);
        glDeleteTextures(1, &mut tex_kos);
        glDeleteTextures(1, &mut tex_rust);
    }

    return 0;
}
